---
layout: post
title: 프로세스 / 스레드
date: 2020-03-09 17:20:29
categories: Java
tags: 프로세스 스레드
comments_gitment: true
---

* TOC
{:toc}

---

## 프로세스
자기 자신만의 주소 공간을 갖는 독립적인 (Self-Contained) 실행 프로그램이다.

멀티 프로세스 : 두 개 이상의 프로세스가 실행되는 것이며, 프로그램이 여러 개 띄워져 있는 형식이다.  
멀티 태스킹 : 두 개 이상의 프로세스를 실행하여 일을 처리하는 것이다.  
```xml
프로그램 : 설치되어 있는 코드, 커맨드, 실행 명령 등의 집합
```

---

## 스레드
경량 프로세스라고도 불리우며, 프로세스 내의 독립적인 제어 또는 순차흐름이다.

멀티 스레드 : 하나의 프로세스에서 여러 개의 스레드가 병행적으로 처리되는 형식이다.

![thread]

프로세스 내에 스레드란 개념이 포함되어 있으므로 스레드와 프로세스는 서로 연관이 되어 있다.
프로세스는 실행중인 프로그램 객체 자체를 말하고, 하나의 실행흐름 자체를 스레드라고 말한다.
하나의 프로세스안에 스레드가 여러개 있는 것을 멀티 스레드라고 말한다.

네트워크 프로그래밍을 할때에는 멀티 쓰레딩이 필요한데, 게임프로그래밍에서 특히 멀티 스레드를 많이 사용하게 된다.
예를 들면, 사용자가 게임을 하려면 크게 1.사용자의 input, 2.네트워크로부터 전송되는 input 두개의 input이 있게 되는데, 
1,2는 동시에 병렬적으로 일어나야 한다.

한 프로세스에 스레드가 2개있다는 말은 해단 프로세스 내 실행흐름이 2개 존재한다는 의미와 동일하다.
한 프로그램 안에서 여러가지 태스크를 동시 수행하고 싶을때, 스레드를 사용하게 된다.
(네트워크 프로그래밍에서는 반드시 필요)  
예를 들면, 가장 간단한 네트워크 프로그래밍인 채팅 프로그램에서는 채팅메시지에서 채팅을 쓰는 부분(키보드 input),
상대방의 채팅메시지를 전달받는 부분(network input) 결과적으로 single thread에서는 부자연스럽게 돌아가게 될 것이다.

하나의 실행중인 프로세스 안에 여러개의 태스킹을 동시에 실행하고 싶을때 스레드를 이용하게 된다.

![process_thread]
![thread_push_pop]

궁극적으로 프로세스간에도 스위치가 일어나고 있고, 스레드 안에서도 스위치가 일어나고 있는 모습 (CPU를 갖고있는 동안)이 된다.  
그리고 프로그래밍시에는 스레드는 각각 별도의 함수로 구성되어 있다.

#### 스레드의 활용
1) 게임 프로그래밍  
게임에 등장하는 캐릭터를 움직이게 하며, 여러 캐릭터들이 동시에 움직인다. 
(대부분의 게임에서 각 캐릭터는 각각의 스레드를 가짐)

2) N/W 프로그래밍  
프로그램의 흐름을 담당하며, 네트워크로부터 데이터를 기다리는 스레드이다.

#### 멀티 프로그래밍
* 여러 개의 프로그램들이 단일 CPU 상에서 동시에 실행되는 것이다.
* 컴퓨터에는 한 개의 CPU내에 존재하기 때문에 진정한 의미로는 여러개의 프로그램이 동시에 실행된다고 볼 수는 없다.
* 한 프로그램이 일부 실행되고 나서 또 다른 프로그램이 일부 실행되는 방식이다.
* 모든 프로그램이 동시에 수행되는것처럼 보이게 된다.

---

## 프로세스의 생명주기
프로세스의 생명주기는 스레드와 유사하며, Java에서 프로세스 생명주기를 나타내는 그림이다.

![process_life_cycle]

프로그램이 실행되면 메인부터 시작하여 하나하나씩 개발자가 짠 함수들이 순차적으로 실행된다. 
이 때 a(), b()라는 함수가 있는데, 동시에 실행하고 싶을때 스레드를 이용하게 되며, 
각 함수별로 해당 함수를 실행하는 스레드를 생성한다.

Java에서 실행되는 모든 엔티티와 스레드는 객체이다. 
스레드를 실행하는 메소드(start()) 실행하면 스레드가 동작하면서 CPU가 점유된 상태가 된다.

스레드 이후 커리큘럼은 파일 IO에 대한 설명이 이루어지는데, 파일 IO 역시 네트워크 프로그래밍과 연결되어 있다. 
왜냐하면 네트워크 프로그래밍은 결국 네트워크 IO를 사용하겠다는 의미이기 때문이다. 

---

## 스레드의 생명주기
스레드는 하나의 생명체 그리고 생명주기를 가진다.

![thread_life_cycle]

1) NEW  
스레드가 생성되었지만, 아직 실행할 준비가 되지 않은 상태이다.

2) RUNNABLE  
현재 실행되고 있거나 실행 준비되어 스케줄링을 기다리는 상태이다.

3) WAITTING  
어떤 Object 타입의 객체 a에 대해 a.wait()을 호출하고 무한대기하면서 다른 스레드가 a.notify(), All()을 불러주기를 기다리는 상태 스레드 동기화를 위해 사용한다.

4) TIME_WAITTING  
sleep(int n)을 호출하여 n밀리초 동안 잠을 자고 있는 상태이다.

5) BLOCK  
스레드가 I/O 작업을 요청하여 작업이 완료되기를 기다리는 상태이며, 실행하면 JVM이 자동으로 현재 스레드를 BLOCK 상태로 만든다.

6) TERMINATED  
스레드가 종료한 상태이다.


#### 스레드의 순환
1) 응용 프로그램의 new Thread()에 의해 스레드 객체가 생성.  
2) JVM은 스레드 관리정보(TCB)를 생성하고 관리.  
생성된 스레드는 NEW 상태이며, JVM은 NEW상태의 스레드는 절대로 스케줄링 하지 않음.  
3) 스레드의 start() 메소드가 호출되면 스케줄링되어 실행 가능한 상태인 RUNNABLE 상태가 됨.  
JVM은 RUNNABLE 상태에 있는 스레드 중에서 하나의 스레드를 선택하고 실행.  
4) 처음으로 스케줄링 되는 스레드는 run() 메소드의 첫 라인부터 실행 시작.  
JVM은 스케줄링 시 우선순위가 높은 스레드를 우선적으로 선택하며, 동일한 우선 순위의 스레드는 라운드 로빈으로 작업됨.  
5) 실행 중인 스레드가 I/O 작업을 하게 되면 BLOCK 상태가 됨.  
BLOCK 상태의 스레드는 입출력 작업이 완료될 때까지 스케줄링되지 않고 계속 대기.  
6) 실행 중인 스레드가 만일 yield() 호출하면 다른 스레드가 스케줄링 될 수 있도록 양보하겠다는 표시이므로 
JVM은 즉각적으로 현재 실행 중인 스레드를 RUNNABLE(준비) 상태로 변경하고 다시 스레드 스케줄링을 실시.  
단, 만일 다른 높은 우선순위의 스레드가 없거나 동일한 우선순위의 다른 스레드가 없다면 이 스레드가 다시 스케줄링됨.  
7) 실행중 중인 스레드가 sleep 호출하면 멈추게 되며, 이 때 JVM은 TIME_WAITTING 상태로 변경.  
잠에서 깨어나면 RUNNABLE 상태로 가게 됨.  
8) 실행중인 스레드가 종료되면 TERMINATED 상태가 되며 JVM은 다시 스케줄링을 시작.  
TERMINATED 상태가 되면 RUNNABLE로 돌아올 수 없음.

JVM은 우선순위를 기반으로 스레드를 스케줄링하며, 가장 높은 우선순위의 스레드를 먼저 실행하고 
동일한 우선순위인 경우 라운드 로빈으로 돌아가면서 실행한다.



[thread]: {{"/assets/images/posts/process_thread_1.jpg" | prepend: site.imgrepo}}
[process_thread]: {{"/assets/images/posts/process_thread_2.png" | prepend: site.imgrepo}}
[thread_push_pop]: {{"/assets/images/posts/process_thread_3.png" | prepend: site.imgrepo}}
[process_life_cycle]: {{"/assets/images/posts/process_thread_4.jpg" | prepend: site.imgrepo}}
[thread_life_cycle]: {{"/assets/images/posts/process_thread_5.png" | prepend: site.imgrepo}}